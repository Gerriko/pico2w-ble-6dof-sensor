/**
 * Copyright (c) 2023 Raspberry Pi (Trading) Ltd. for temp_sensor example code
 * This project was based on the temp_sensor example downloaded via the VSCode Raspberry Pi Pico Project Extension
 * The expanded code to include the LSM303 sensor was then primarily generated by Google Code Assist
 * This includes comments made throughout
 * Further modifications/tweaks done by C Gerrish (Gerrikoio) (c) May 2025
 *
 * SPDX-License-Identifier: BSD-3-Clause applies
 * 
 */

#include <stdio.h>
#include <math.h>
#include <string.h> // For memcpy

#include "btstack.h"
#include "pico/cyw43_arch.h"
#include "pico/btstack_cyw43.h"
#include "hardware/adc.h"
#include "hardware/i2c.h"
#include "pico/stdlib.h"

#include "server_common.h"
#include "lsm303_sensor/lsm303dlm.h"

// I2C defines
// This example will use I2C0 on GPIO8 (SDA) and GPIO9 (SCL) running at 400KHz.
// Pins can be changed, see the GPIO function select table in the datasheet for information on GPIO assignments
#define I2C_PORT i2c0
#define I2C_SDA 16
#define I2C_SCL 17

// The heartbeat handler will be called at this period.
// This is how often it checks to update the lsm303 sensor values via BLE
#define HEARTBEAT_PERIOD_MS 500

// Target frequency for accelerometer reads (Hz)
// Note best case frequency for sensor data reads is 3.7kHz with sensor Output Data Rate (ODR) limited to 1kHz.
#define SENSOR_READ_FREQUENCY_HZ 100

// Corresponding period in microseconds to read lsm303 sensor
const uint64_t SENSOR_READ_PERIOD_US = 1000000 / SENSOR_READ_FREQUENCY_HZ;

// Moving Average Filter definitions (size of array)
#define MOVING_AVG_SIZE 50

// For converting radians to degrees
#define RAD_TO_DEG (180.0 / M_PI)

// TEMP_UPDATE_FACTOR was the '10' in 'counter % 10' when HEARTBEAT_PERIOD_MS was 1000ms.
// This means on board pico temperature reading will be updated every 5000ms = 5 seconds.
#define TEMP_UPDATE_INTERVAL_MS 5000

// LED_TOGGLE_INTERVAL_MS is the desired interval for the LED to change its state.
// Originally, LED toggled every heartbeat, and heartbeat was 1000ms.
#define LED_TOGGLE_INTERVAL_MS 1000

static btstack_timer_source_t heartbeat;
static btstack_packet_callback_registration_t hci_event_callback_registration;

static double roll_xz_deg = 0;
static double pitch_yz_deg = 0;
static double heading_uncompensated_deg = 0;
static double heading_compensated_deg = 0;

/**
 * @brief Converts a double-precision floating-point number to the
 *        bit representation of an IEEE 754 single-precision (float32)
 *        value, returned as a uint32_t.
 * @param input_value The double value to convert.
 * @return The uint32_t containing the bits of the float32 representation.
 */

uint32_t double_to_float32_bits(double input_value) {
    float f_val = (float)input_value; // Convert double to float (float32)
    uint32_t u_bits;
    // Reinterpret the bits of the float as a uint32_t
    // Ensure that float is indeed 32-bits on this platform, which is typical.
    static_assert(sizeof(float) == sizeof(uint32_t), "Size of float is not 32 bits");
    memcpy(&u_bits, &f_val, sizeof(f_val));
    return u_bits;
}

/**
 * @brief Handles periodic tasks for the BLE application.
 *        This function is called by a BTstack timer at regular intervals (HEARTBEAT_PERIOD_MS).
 *        It updates sensor data (pitch, roll, heading) for BLE notifications,
 *        polls the on-board temperature sensor, toggles an LED, and reschedules itself.
 * @param ts Pointer to the btstack_timer_source structure that triggered this handler.
 */

static void heartbeat_handler(struct btstack_timer_source *ts) {
    static uint32_t counter = 0;
    counter++;
    static int led_on = true; // LED state variable

    // Calculate the number of heartbeats required to achieve the original 10-second temperature update interval.
    // Original interval: TEMP_UPDATE_FACTOR * 1000 ms.
    // New ticks: (TEMP_UPDATE_FACTOR * 1000ms) / HEARTBEAT_PERIOD_MS
    const uint32_t temp_update_trigger_ticks = (TEMP_UPDATE_INTERVAL_MS) / HEARTBEAT_PERIOD_MS;

    // update latest orientation sensor data to be used by the BLE server

    pitch_deg = double_to_float32_bits(pitch_yz_deg);
    if (g_notification_status.pitch) {
        g_data_ready_status.pitch = true; // Mark for initial send
        att_server_request_can_send_now_event(con_handle);
    }
    sleep_ms(1);
    roll_deg = double_to_float32_bits(roll_xz_deg);
    if (g_notification_status.roll) {
        g_data_ready_status.roll = true; // Mark for initial send
        att_server_request_can_send_now_event(con_handle);
    }
    sleep_ms(1);
    heading_deg_raw = double_to_float32_bits(heading_uncompensated_deg);
    if (g_notification_status.heading_raw) {
        g_data_ready_status.heading_raw = true; // Mark for initial send
        att_server_request_can_send_now_event(con_handle);
    }
    sleep_ms(1);
    heading_deg_comp = double_to_float32_bits(heading_compensated_deg);    
    if (g_notification_status.heading_comp) {
        g_data_ready_status.heading_comp = true; // Mark for initial send
        att_server_request_can_send_now_event(con_handle);
    }

    if (counter % temp_update_trigger_ticks == 0) {
        poll_temp();
        if (g_notification_status.temperature) {
            g_data_ready_status.temperature = true; // Mark temperature data as ready to be sent
            att_server_request_can_send_now_event(con_handle);
        }
    }

    // Calculate the number of heartbeats required to achieve the original LED toggle interval.
    const uint32_t led_toggle_trigger_ticks = LED_TOGGLE_INTERVAL_MS / HEARTBEAT_PERIOD_MS;

    if (counter % led_toggle_trigger_ticks == 0) {
        led_on = !led_on;
        cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, led_on);
    }
    // Restart timer
    btstack_run_loop_set_timer(ts, HEARTBEAT_PERIOD_MS);
    btstack_run_loop_add_timer(ts);
}

/**
 * @brief Main application entry point.
 *        Initializes the system, including standard I/O, CYW43 Wi-Fi/Bluetooth chip,
 *        I2C for the LSM303DLM sensor, the LSM303DLM sensor itself, and the ADC for
 *        the on-board temperature sensor.
 *        It then sets up the Bluetooth Low Energy (BLE) stack, registers event handlers,
 *        and starts a periodic timer for BLE updates (heartbeat_handler).
 *        Finally, it enters an infinite loop to continuously read and process sensor data
 *        from the LSM303DLM, applying a moving average filter and calculating orientation.
 * @return int Returns 0 on successful execution (though it's an infinite loop), or -1 on initialization failure.
 */
int main()
{
    accel_data_t accel_data;
    mag_data_t mag_data;    
    
    
    // Buffers for each axis
    int16_t accel_x_buffer[MOVING_AVG_SIZE];
    int16_t accel_y_buffer[MOVING_AVG_SIZE];
    int16_t accel_z_buffer[MOVING_AVG_SIZE];

    int16_t mag_x_buffer[MOVING_AVG_SIZE];
    int16_t mag_y_buffer[MOVING_AVG_SIZE];
    int16_t mag_z_buffer[MOVING_AVG_SIZE];

    // Sums for each axis (use int32_t to prevent overflow when summing int16_t)
    int32_t sum_x_Accel = 0;
    int32_t sum_y_Accel = 0;
    int32_t sum_z_Accel = 0;

    int32_t sum_x_Mag = 0;
    int32_t sum_y_Mag = 0;
    int32_t sum_z_Mag = 0;

    int16_t avg_accel_x = 0;
    int16_t avg_accel_y = 0;
    int16_t avg_accel_z = 0;

    int16_t avg_mag_x = 0;
    int16_t avg_mag_y = 0;
    int16_t avg_mag_z = 0;

    double roll_rad = 0;
    double pitch_rad = 0;
    double cos_roll = 0;
    double sin_roll = 0;
    double cos_pitch = 0;
    double sin_pitch = 0;

    double mag_x_compensated = 0;
    double mag_y_compensated = 0;

    // Moving average variables
    uint8_t buffer_index = 0;
    uint8_t data_point_count = 0; // To track how many points are in the buffer initially

    // initialise external variables
    sample_rate = SENSOR_READ_FREQUENCY_HZ;
    pitch_deg = 0;
    roll_deg = 0;
    heading_deg_raw = 0;
    heading_deg_comp = 0;
    
    memset(&g_notification_status, 0, sizeof(notification_status_t));
    memset(&g_data_ready_status, 0, sizeof(data_ready_status_t));

    stdio_init_all();

    // initialize CYW43 driver architecture (will enable BT if/because CYW43_ENABLE_BLUETOOTH == 1)
    if (cyw43_arch_init()) {
        printf("failed to initialise cyw43_arch\r\n");
        return -1;
    }

    printf("\n\n");
    // Initialize the LSM303DLM sensor
    lsm303dlm_init(I2C_PORT, I2C_SDA, I2C_SCL);

    if (!lsm303dlm_config(I2C_PORT)) {
        printf("Failed to initialize LSM303DLM!\r\n");
        return -1;
    }

    printf("LSM303DLM initialized & configured successfully!\r\n");
    printf("Attempting to read sensor data at %d Hz (period: %llu us).\r\n", SENSOR_READ_FREQUENCY_HZ, SENSOR_READ_PERIOD_US);
    printf("\r\n\r\n");

    uint64_t last_accel_read_schedule_us = time_us_64();

    // Initialise adc for the temp sensor
    adc_init();
    adc_select_input(ADC_CHANNEL_TEMPSENSOR);
    adc_set_temp_sensor_enabled(true);

    l2cap_init();
    sm_init();

    att_server_init(profile_data, att_read_callback, att_write_callback);    

    // inform about BTstack state
    hci_event_callback_registration.callback = &packet_handler;
    hci_add_event_handler(&hci_event_callback_registration);

    // register for ATT event
    att_server_register_packet_handler(packet_handler);

    // set one-shot btstack timer
    heartbeat.process = &heartbeat_handler;
    btstack_run_loop_set_timer(&heartbeat, HEARTBEAT_PERIOD_MS);
    btstack_run_loop_add_timer(&heartbeat);

    // turn on bluetooth!
    hci_power_control(HCI_POWER_ON);
    
    // btstack_run_loop_execute is only required when using the 'polling' method (e.g. using pico_cyw43_arch_poll library).
    // This example uses the 'threadsafe background` method, where BT work is handled in a low priority IRQ, so it
    // is fine to call bt_stack_run_loop_execute() but equally you can continue executing user code.

#if 0 // btstack_run_loop_execute() is not required, so lets not use it
    btstack_run_loop_execute();
#else
    // this core is free to do it's own stuff except when using 'polling' method (in which case you should use 
    // btstacK_run_loop_ methods to add work to the run loop.
    
    // this is a forever loop in place of where user code would go.
    while (true) {
        uint64_t current_time_us = time_us_64();

        // Check if it's time to attempt an accelerometer read
        if (current_time_us - last_accel_read_schedule_us >= SENSOR_READ_PERIOD_US) {
            // Update the schedule time for the next read.
            // This aims to maintain an average frequency. If the read operation
            // takes longer than SENSOR_READ_PERIOD_US, this will cause subsequent
            // read attempts to occur immediately after the previous one finishes,
            // effectively making reads back-to-back.
            last_accel_read_schedule_us += SENSOR_READ_PERIOD_US;

            // To prevent last_accel_read_schedule_us from falling too far behind current_time_us
            // (e.g. after a very long operation or debugger pause), reset if it's more than one period old.
            // This ensures we schedule from "now" if we are significantly lagging.
            if (last_accel_read_schedule_us < current_time_us - SENSOR_READ_PERIOD_US) {
                last_accel_read_schedule_us = current_time_us;
            }

            // Read accelerometer and magnetometer data
            if (lsm303dlm_read_accel(I2C_PORT, &accel_data) && lsm303dlm_read_mag(I2C_PORT, &mag_data)) {
                // printf("X: %6d\t Y: %6d\t Z: %6d\n", accel_data.x, accel_data.y, accel_data.z);

                // --- Moving Average Calculation ---

                // If the buffer is already full, subtract the oldest value from sums
                if (data_point_count >= MOVING_AVG_SIZE) {
                    sum_x_Accel -= accel_x_buffer[buffer_index];
                    sum_y_Accel -= accel_y_buffer[buffer_index];
                    sum_z_Accel -= accel_z_buffer[buffer_index];
                    sum_x_Mag -= mag_x_buffer[buffer_index];
                    sum_y_Mag -= mag_y_buffer[buffer_index];
                    sum_z_Mag -= mag_z_buffer[buffer_index];
                }

                // Add new data to buffer
                accel_x_buffer[buffer_index] = accel_data.x;
                accel_y_buffer[buffer_index] = accel_data.y;
                accel_z_buffer[buffer_index] = accel_data.z;
                mag_x_buffer[buffer_index] = mag_data.x;
                mag_y_buffer[buffer_index] = mag_data.y;
                mag_z_buffer[buffer_index] = mag_data.z;

                // Add new data to sums
                sum_x_Accel += accel_data.x;
                sum_y_Accel += accel_data.y;
                sum_z_Accel += accel_data.z;
                sum_x_Mag += mag_data.x;
                sum_y_Mag += mag_data.y;
                sum_z_Mag += mag_data.z;

                // Increment buffer index (circularly)
                buffer_index = (buffer_index + 1) % MOVING_AVG_SIZE;

                // Increment data point count until buffer is full
                if (data_point_count < MOVING_AVG_SIZE) {
                    data_point_count++;
                }

                // Calculate and print moving average if buffer is full
                if (data_point_count >= MOVING_AVG_SIZE) {
                    avg_accel_x = sum_x_Accel / MOVING_AVG_SIZE;
                    avg_accel_y = sum_y_Accel / MOVING_AVG_SIZE;
                    avg_accel_z = sum_z_Accel / MOVING_AVG_SIZE;
                    avg_mag_x = sum_x_Mag / MOVING_AVG_SIZE;
                    avg_mag_y = sum_y_Mag / MOVING_AVG_SIZE;
                    avg_mag_z = sum_z_Mag / MOVING_AVG_SIZE;

                    // Calculate Tilt (X, Z) and Roll (Y, Z)
                    // atan2(y,x) gives angle of vector (x,y) from positive x-axis
                    roll_xz_deg = atan2((double)avg_accel_x, (double)avg_accel_z) * RAD_TO_DEG;
                    pitch_yz_deg = atan2((double)avg_accel_y, (double)avg_accel_z) * RAD_TO_DEG;

                    // --- Heading Calculation ---
                    // Uncompensated heading (raw from magnetometer XY plane)
                    heading_uncompensated_deg = atan2((double)avg_mag_y, (double)avg_mag_x) * RAD_TO_DEG;                    
                    if (heading_uncompensated_deg < 0) heading_uncompensated_deg += 360.0;

                    // Tilt-compensated heading
                    roll_rad = roll_xz_deg * (M_PI / 180.0); // roll_xz_deg is our pitch
                    pitch_rad = pitch_yz_deg * (M_PI / 180.0);  // pitch_yz_deg is our roll

                    cos_roll = cos(pitch_rad);
                    sin_roll = sin(pitch_rad);
                    cos_pitch = cos(roll_rad);
                    sin_pitch = sin(roll_rad);

                    mag_x_compensated = (double)avg_mag_x * cos_pitch + (double)avg_mag_y * sin_roll * sin_pitch - (double)avg_mag_z * cos_roll * sin_pitch;
                    mag_y_compensated = (double)avg_mag_y * cos_roll + (double)avg_mag_z * sin_roll;

                    heading_compensated_deg = atan2(mag_x_compensated, mag_y_compensated) * RAD_TO_DEG;
                    
                    if (heading_compensated_deg < 0) {
                        heading_compensated_deg += 360.0;
                    }

                    //printf("avg_accel_x: %6d\t avg_accel_y: %6d\t avg_accel_z: %6d\r\n", avg_accel_x, avg_accel_y, avg_accel_z);
                    //printf("Roll(XZ):%6.1f, Pitch(YZ):%6.1f, Head_Raw:%5.1f, Head_Comp:%5.1f\r\n", roll_xz_deg, pitch_yz_deg, heading_uncompensated_deg, heading_compensated_deg);
                }
                // --- End of Moving Average Calculation ---

            } else {
                printf("Failed to read sensor data!\r\n");
            }
        }
    }
#endif
    return 0;
}
