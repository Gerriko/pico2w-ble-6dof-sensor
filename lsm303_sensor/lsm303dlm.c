// lsm303dlm.c
// Note that this code was generated by Google Code Assist


#include "pico/stdlib.h"
#include "lsm303dlm.h"
#include <stdio.h>
#include "hardware/i2c.h" // Include the i2c header

// Helper function to read a register
static bool lsm303dlm_read_reg(i2c_inst_t *i2c, uint8_t addr, uint8_t reg, uint8_t *data, size_t len) {
    int ret;
    ret = i2c_write_blocking(i2c, addr, &reg, 1, true);
    if (ret < 0) return false;
    ret = i2c_read_blocking(i2c, addr, data, len, false);
    if (ret < 0) return false;
    return true;
}

// Helper function to write a register
static bool lsm303dlm_write_reg(i2c_inst_t *i2c, uint8_t addr, uint8_t reg, uint8_t data) {
    uint8_t buf[2] = {reg, data};
    int ret = i2c_write_blocking(i2c, addr, buf, 2, false);
    if (ret < 0) return false;
    return true;
}

void lsm303dlm_init(i2c_inst_t *i2c, uint sda_pin, uint scl_pin) {
    // Initialize I2C if not already initialized
    i2c_init(i2c, 100 * 1000);
    gpio_set_function(sda_pin, GPIO_FUNC_I2C);
    gpio_set_function(scl_pin, GPIO_FUNC_I2C);
    gpio_pull_up(sda_pin);
    gpio_pull_up(scl_pin);

}

bool lsm303dlm_config(i2c_inst_t *i2c) {
    // Initialize Accelerometer
    // Enable all axes, normal mode
    if (!lsm303dlm_write_reg(i2c, LSM303DLM_ACCEL_ADDR, LSM303DLM_ACCEL_CTRL_REG1_A, ACCEL_XYZ_ENABLE_10HZ)) return false;

    // Set full scale to +/- 2g
    if (!lsm303dlm_write_reg(i2c, LSM303DLM_ACCEL_ADDR, LSM303DLM_ACCEL_CTRL_REG4_A, ACCEL_FS_2G_CONT_UPDATE)) return false;

    // Initialize Magnetometer
    // Set continuous-measurement mode
    if (!lsm303dlm_write_reg(i2c, LSM303DLM_MAG_ADDR, LSM303DLM_MAG_MR_REG_M, MAG_CONTINUOUS_MODE)) return false;

    // Set gain to +/- 1.3 Gauss
    if (!lsm303dlm_write_reg(i2c, LSM303DLM_MAG_ADDR, LSM303DLM_MAG_CRB_REG_M, MAG_GAIN_1_3_GAUSS)) return false;

    // Set data rate to 15 Hz
    if (!lsm303dlm_write_reg(i2c, LSM303DLM_MAG_ADDR, LSM303DLM_MAG_CRA_REG_M, MAG_DATA_RATE_15HZ)) return false;

    return true;
}

bool lsm303dlm_read_accel(i2c_inst_t *i2c, accel_data_t *accel_data) {
    uint8_t data[6];
    // Read all 6 accelerometer registers at once
    if (!lsm303dlm_read_reg(i2c, LSM303DLM_ACCEL_ADDR, LSM303DLM_ACCEL_OUT_X_L_A | 0x80, data, 6)) return false;

    // Combine the high and low bytes
    accel_data->x = (int16_t)((data[1] << 8) | data[0]);
    accel_data->y = (int16_t)((data[3] << 8) | data[2]);
    accel_data->z = (int16_t)((data[5] << 8) | data[4]);

    return true;
}

uint8_t lsm303dlm_get_accel_fs(i2c_inst_t *i2c) {
    uint8_t reg_value;
    // Read the CTRL_REG4_A register which contains the FS bits
    if (!lsm303dlm_read_reg(i2c, LSM303DLM_ACCEL_ADDR, LSM303DLM_ACCEL_CTRL_REG4_A, &reg_value, 1)) {
        fprintf(stderr, "Error reading CTRL_REG4_A\n");
        return 0; // Indicate read error
    }

    // Isolate the FS bits (bits 5 and 4)
    // FS1 FS0 | Full Scale Selection
    // --------|---------------------
    //   0  0  | +/- 2g (default)
    //   0  1  | +/- 4g
    //   1  0  | +/- 8g
    //   1  1  | Reserved
    uint8_t fs_bits = (reg_value >> 4) & 0x03; // Mask is 0b00000011

    switch (fs_bits) {
        case 0x00: return 2;  // +/- 2g
        case 0x01: return 4;  // +/- 4g
        case 0x02: return 8;  // +/- 8g
        default:   return 0;  // Indicate error or reserved value (11)
    }
}

float lsm303dlm_get_mag_fs(i2c_inst_t *i2c) {
    uint8_t reg_value;
    // Read the CRB_REG_M register which contains the Gain (GN) bits
    if (!lsm303dlm_read_reg(i2c, LSM303DLM_MAG_ADDR, LSM303DLM_MAG_CRB_REG_M, &reg_value, 1)) {
        fprintf(stderr, "Error reading CRB_REG_M\n");
        return 0.0f; // Indicate read error
    }

    // Isolate the GN bits (bits 7, 6, 5)
    // GN2 GN1 GN0 | Full Scale (Gauss)
    // ------------|--------------------
    //  0   0   1  | +/- 1.3 (default)
    //  0   1   0  | +/- 1.9
    //  0   1   1  | +/- 2.5
    //  1   0   0  | +/- 4.0
    //  1   0   1  | +/- 4.7
    //  1   1   0  | +/- 5.6
    //  1   1   1  | +/- 8.1
    //  0   0   0  | Reserved
    uint8_t gn_bits = (reg_value >> 5) & 0x07; // Mask is 0b00000111

    switch (gn_bits) {
        case 0x01: return 1.3f;
        case 0x02: return 1.9f;
        case 0x03: return 2.5f;
        case 0x04: return 4.0f;
        case 0x05: return 4.7f;
        case 0x06: return 5.6f;
        case 0x07: return 8.1f;
        default:   return 0.0f; // Indicate error or reserved value (000)
    }
}

bool lsm303dlm_read_mag(i2c_inst_t *i2c, mag_data_t *mag_data) {
    uint8_t data[6];
    // Read all 6 magnetometer registers at once
    if (!lsm303dlm_read_reg(i2c, LSM303DLM_MAG_ADDR, LSM303DLM_MAG_OUT_X_H_M, data, 6)) return false;

    // Combine the high and low bytes
    mag_data->x = (int16_t)((data[0] << 8) | data[1]);
    mag_data->z = (int16_t)((data[2] << 8) | data[3]);
    mag_data->y = (int16_t)((data[4] << 8) | data[5]);

    return true;
}
